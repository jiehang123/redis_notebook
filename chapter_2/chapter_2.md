
## 简单动态字符串
　　Redis 构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型，并将 SDS 用作 Redis 的默认字符串表示，而 C 字符串只作为字面量。

### SDS 的定义
　　在 sds.h / sdshdr 结构表示一个 SDS 值 

![Aaron Swartz](https://raw.githubusercontent.com/martin-1992/redis_notebook/master/chapter_2/chapter_2_p1.png)

- free = 0，表示这个 SDS 的剩余空间已经用完；
- len = 5，表示这个 SDS 保存一个 5 字节长的字符串；
- buf 属性是一个 char 类型的数组，数组的前五个字节分别保存了 "R"、"e"、"d"、"i"、"s" 五个字符，最后一个字节保存空字符 "\0"，这个空字节占据一个字节长度，但不计算在 len 里。使用空字节进行结尾，SDS 可以直接重用一部分 C 字符串函数库里的函数，如 printf；

### SDS 与 C 字符串的区别
　　C 语言使用长度为 N+1 的字符串数组来表示长度为 N 的字符串，并且字符串数组的最后一个元素总是空字符 "\0"，但这种不能满足 Redis 对字符串在安全性、效率以及功能方面的要求，接下来对比这两者区别。

#### 常数复杂度获取字符串长度
　　C 语言的字符串并不记录自身的长度信息，所以为了获取一个 C 字符串的长度，需要遍历整个字符串，复杂度为 O(N)。而 SDS 在 len 属性中记录了 SDS 本身的长度，获取一个 SDS 长度的复杂度仅为 O(1)，这样确保了获取字符串长度的动作不会成为 Redis 的性能瓶颈。
　　例如，对一个非常长的字符串键反复执行 STRLEN 命令，也不会对系统性能造成影响，因为 STRLEN 命令复杂度仅为 O(1);

#### 杜绝缓冲区溢出
　　由于 C 字符串不记录自身长度，容易造成缓冲区溢出。假设程序里有两个在内存中紧邻着的 C 字符串 s1 和 s2，其中 s1 保存字符串 "Redis"，s2 保存字符串 "MongoDB"，如下图

![Aaron Swartz](https://raw.githubusercontent.com/martin-1992/redis_notebook/master/chapter_2/chapter_2_p2.png)

　　当执行 strcat(s1, " Cluster") 将 s1 的内容修改为 "Redis Cluster"，忘记在 s1 上分配足够空间，导致 s1 的数据将溢出到 s2 所在的空间，s2 保存的内容被修改，如下：

![Aaron Swartz](https://raw.githubusercontent.com/martin-1992/redis_notebook/master/chapter_2/chapter_2_p3.png)

　　而 SDS 的 API 会先检查 SDS 的空间是否满足修改所需的要求，不满足会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，从而避免缓冲区溢出问题。

#### 减少修改字符串时带来的内存重分配次数
　　因为 C 字符串并不记录自身的长度，所以一个包含 N 个字符出 C 字符串，其底层实现总是一个 N + 1 个字符长的数组（额外的一个字符空间用于保存空字符串），这就导致每次增长或缩短一个 C 字符串，程序都要对这个数组进行一次内存重分配的操作:
- 增长字符串，如拼接新字符串，需要扩展数组空间大小，如果没有回产生缓冲区溢出；
- 缩短字符串，如截断字符串，需通过内存分配释放字符串不再使用的空间，如果没有会产生内存泄漏；

　　而 SDS 则通过未使用的空间来实现空间预分配和惰性空间释放两种优化策略：
- **空间预分配，用于优化 SDS 的字符串增长操作。**当 SDS 的API 对一个 SDS 进行修改，并且需要对 SDS 进行空间扩展时，程序不仅会为 SDS 分配修改所需要的空间，还会为 SDS 分配额外的未使用空间。如果 SDS 的长度（len 属性的值）小于 1MB，则分配和 len 属性同样大小的未使用空间，如在修改后，SDS 的 len 变成 13字节，那么程序也会分配 13 字节未使用空间。这样 buf 数组的实际长度为 13 + 13 + 1（额外一节保存空字符）= 27字节。如果 SDS 的长度大于等于 1MB，程序则分配 1MB 的未使用空间，即 30MB + 1MB + 1byte（保存空字符）。通过空间预分配策略，来减少连续执行字符串增长操作所需的内存重分配次数；
- **惰性空间释放，用于优化 SDS 的字符串缩短操作。**当 SDS 的 API 需要缩短 SDS 保存的字符串时，程序不会对内存重新分配来回收缩短后多出来的字节，而是留着以后字符粗增长使用。如需要释放，也可以使用对应的 API 进行手动释放内存。

#### 二进制安全
　　SDS 以处理二进制的方式来保存数据，这样 Redis 不仅可以保存文本数据，还可以保存图片、音频、视频等二进制数据。而 C 字符串里是不能包含空字符串，因为读入空字符会被误认为是字符串结尾，这些限制使得 C 字符串只能保存文本数据。

#### 兼容部分 C 字符串函数
　　虽然 SDS 的 API 是二进制安全，但一样遵循 C 字符串以空字符结尾的管理，即会将 SDS 保存的数据末尾设置为空字符，并且在分配空间时会多分配一个字节来容纳这个空字符。这是为了能重用 C 函数库的一些函数，避免重写代码。

### 总结
　　对 C 字符串和 SDS 之间区别的总结：
- C 字符串获取字符串长度的复杂度为 O(N)。SDS 获取字符串长度的复杂度为 O(1)，有个 len 属性记录长度；
- C 字符串 API 不安全，在增加字符串时不进行内存分配下，可能会造成缓冲区溢出。SDS API 是安全的，在增加字符串时会对其内存进行检查，有需要时增加内存，不会造成缓冲区溢出；
- C 字符串修改字符串长度 N 次必须执行 N 次内存重分配。SDS 修改字符串长度 N 次最多需要执行 N 次内存重分配，使用空间预分配和惰性空间释放策略；
- C 字符串只能保存文本数据。SDS 能保存文本或二进制数据；
- C 字符串可使用所有的 &lt;string.h&gt; 库中的函数。而 SDS 只能使用部分 &lt;string.h&gt; 库中的函数；
