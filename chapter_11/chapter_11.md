
## AOF 持久化
　　与 Redis 持久化通过保存数据库中的键值对来记录数据状态不同，AOF 持久化是通过保存 Redis 服务器所执行的写命令来记录数据库状态的。服务器在启动时，通过载入和执行 AOF 文件中保存的命令来还原服务器关闭之前的数据库状态。
  
![Aaron Swartz](https://raw.githubusercontent.com/martin-1992/redis_notebook/master/chapter_11/chapter_11_p1.png)

### AOF 持久化的实现
　　AOF 持久化功能的实现分为追加（append）、文件写入、文件同步（sync）是三个步骤。

#### 命令追加
　　当 AOF 持久化功能处于打开状态时，服务器在执行完一个写入命令后，会以协议格式将被执行的写命令追加到服务器状态的 aof_buf 缓存区的末尾。举例，客户端向服务器发送 "redis>SET KEY VALUE"，则服务器在执行这个 SET 命令后，会将以下协议内容追加到 aof_buf 缓冲区的末尾：

![Aaron Swartz](https://raw.githubusercontent.com/martin-1992/redis_notebook/master/chapter_11/chapter_11_p2.png)

#### AOF 文件的写入与同步
　　Redis 的服务器进程是一个事件循环，这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像 serverCron 函数这样需要定时运行的函数。<br />
　　因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到 aof_buf 缓冲区里，所以在服务器每次结束一个事件循环之前，都会调用 flushAppendOnlyFile 函数，考虑是否需要将 aof_buf 缓存区中的内容写入和保存到 AOF 文件里。<br />
　　这是为了提高文件的写入效率，即在调用 write 函数将一些数据写入到文件时，程序通常是先将写入数据暂时保存到一个内存缓存区，等到缓存区空间满了，或者超过指定的时限后，才真正将缓存区中的数据写入到磁盘里。当然如果计算机发生停机，则保存在内存缓冲区的希尔数据将丢失。可使用 fsync 和 fdatasync 两个同步函数，强制写入到磁盘里。

#### AOF 文件的载入与数据还原
　　因为 AOF 文件保存了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍 AOF 文件里保存的写命令，就可以还原服务器关闭之前的数据库状态，步骤如下：
  
- 创建一个不带网络连接的微客户端。因为 Redis 的命令只能在客户端上下文中执行，而载入 AOF 文件时所使用的命令直接来源于 AOF 文件而不是网络连接，所以服务器使用一个没有网络连接的伪客户端来执行 AOF 文件保存的写命令；
- 从 AOF 文件中分析并读取出一条写命令；
- 使用伪客户端执行被读出的写命令；
- 重复第二步和第三步，直到 AOF 文件中的所有写命令都被处理完为止。

![Aaron Swartz](https://raw.githubusercontent.com/martin-1992/redis_notebook/master/chapter_11/chapter_11_p3.png)

　　注意，通常情况下，Redis 只会将那些对数据库进行修改的命令写入到 AOF 文件中，并复制到各个从服务器，但一个命令如没对数据库进行修改，则认为是只读命令，不会被写入到 AOF 文件中。<br />
　　但有两个命令是例外的，PUBSUB 命令和 SCRIPT LOAD 命令。PUBSUB 命令虽没有修改数据库，但 PUBSUB 命令向频道的所有订阅者发送消息，而接收到消息的所有客户端的状态都会因为这个命令而改变。同理 SCRIPT LOAD 岁没有修改数据库，但修改了服务器状态。

### AOF 重写
　　因为 AOF 持久化是通过保存被执行的写命令来记录数据库状态的，所以随着服务器的运行，AOF 文件的内容会越来越多。而 AOF 的文件体积越大，使用 AOF 文件来进行数据还原所需的时间就越多。<br />
　　为了解决这个问题，Redis 提供了 AOF 文件重功能，可以创建一个新的 AOF 文件来替代现有的 AOF 文件，新旧两个 AOF 文件所保存的数据库状态相同，但新 AOF 文件不会包含任何浪费空间的冗余命令，所以文件体积小。<br />
　　AOF 文件重写并不是对现有的 AOF 文件进行任何读取、分析或写入操作，而是通过读取服务器当前的数据库状态来实现的，如下对 list 键执行以下命令：

```redis
redis> PRUSH list "A" "B"  // {"A", "B"}

redis>PRUSH list "C"    // {"A", "B", "C"}

redis>PRUSH list "D" "E"   // {"A", "B", "C", "D", "E"}
```

　　AOF 持久化会写入三条命令，而AOF 重写时是直接从数据库中读取 list 的值，然后使用一条命令 PRUSH list "A", "B", "C", "D", "E" 来代替保存在 AOF 文件中的三条命令。AOF 重写功能的实现原理，从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令。<br />
　　在实际中，为避免在执行命令时造成客户端输入缓冲区溢出，重写程序在处理列表、哈希表、集合、有序集合这四种可能会带有多个元素的键时，会先检查键所包含的元素数量，比如列表中的元素数量或包含多个键值对的哈希表键数量超过了 redis.h / REDIS_AOF_REWRITE_ITEMS_PER_CMD 常量的值，当前版本是64，超过64，则重写程序将使用多条命令来记录键的值。

#### AOF 后台重写流程
　　AOF 重写程序 aof_rewrite 会进行大量的写入操作，而因为 Redis 服务器使用单线程来处理命令请求，所以使用 aof_rewrite 会导致线程长时间阻塞，服务器无法处理其他的命令请求，所以将 AOF 重写程序放到子进程执行，这样（服务器进程）父进程可以继续处理命令请求，并且子进程使用的是带有服务器进程的数据副本，在避免使用锁的情况下，保证数据的安全性。但存在一个问题，子进程在进行 AOF 重写时，服务器进程（父进程）还会继续处理命令请求，这就导致了子进程的数据库状态和父进程的数据库状态不一致。<br />
　　为解决数据不一致问题，Redis 服务器设置了AOF 重写缓冲区，在创建子进程之后开始使用。即在子进程执行 AOF 重写期间，父进程会执行客户端发来的命令，同时将执行后的写命令追加到 AOF 缓冲区和 AOF 重写缓冲区。
  
![Aaron Swartz](https://raw.githubusercontent.com/martin-1992/redis_notebook/master/chapter_11/chapter_11_p4.png)

　　AOF 缓冲区的命令内容会被写入和同步到 AOF 文件，保证 AOF 文件正常记录父进程的命令。同时这些命令也会记录到 AOF 重写缓冲区里，当子进程完成 AOF 重写工作后，会向父进程发送一个信号，这个信号会对服务器进程（父进程）进行阻塞。在阻塞期间，会将 AOF 重写缓冲区中的所有命令内容写入到新的 AOF 文件中，这时新 AOF 文件所保存的数据库状态和服务器当前的数据库状态一致，然后对新的 AOF 文件进行该名，原子地覆盖现有的 AOF 文件，完成新旧两个 AOF 文件的替换。完成之后，阻塞消失，父进程继续处理命令请求。
